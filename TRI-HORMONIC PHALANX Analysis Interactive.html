<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRI-HORMONIC PHALANX Analysis Interactive Individual</title>
    <meta name="description" content="Interactive analysis tool for the Tri-Hormonic Phalanx Tri-Band Enhancer.">
    <meta name="author" content="RhPf Electronics">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script>
        if (!window.Plotly) {
            document.write('<script src="/path-to-local-plotly/plotly-latest.min.js"><\/script>');
        }
    </script>
    <style>
        body {
            display: flex;
            flex-direction: row; /* Stack pedal and graph horizontally */
            justify-content: left;
            align-items: top;
            margin: 0;
            height: auto;
        }

        #pedal-container {
            width: 100%; /* Scale pedal container to fit the viewport */
            height: 100vh; /* Maintain aspect ratio */
            margin: 0;
        }

        #pedal-svg {
            width: 100%; /* Make the SVG scale with the container */
            height: 100vh; /* Maintain aspect ratio */
            margin: 0;
        }

        #graph {
            width: 100%; /* Take up most of the width */
            height: 100vh; /* Dynamically scale height relative to the viewport */
            margin: 0; /* Add some spacing between graph and pedal */
        }

    </style>
</head>
<body>
    <!-- Pedal with Knobs -->
    <div id="pedal-container">
        <svg id="pedal-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1884 3600">
            <!-- Background Image -->
            <image href="https://thomasbe86.github.io/plotly-plot/TRI-HORMONIC-PHALANX-RhPf-Distortion-Guitar-Pedal-Interactive-Graph-Model.png" x="0" y="0" width="1884" height="3600" />
<g id="knob-gainacth" transform="translate(1540, 655)">
    <circle cx="0" cy="0" r="170" fill="#FFF0CA" stroke="none" stroke-width="3" />
    <line id="gainacth-pointer" x1="0" y1="0" x2="0" y2="-150" stroke="#000" stroke-width="15" stroke-linecap="round" />
</g>

<g id="knob-gaingh" transform="translate(950, 1390)">
    <circle cx="0" cy="0" r="170" fill="#FFF0CA" stroke="none" stroke-width="3" />
    <line id="gaingh-pointer" x1="0" y1="0" x2="0" y2="-150" stroke="#000" stroke-width="15" stroke-linecap="round" />
</g>

<g id="knob-gainigf1" transform="translate(345, 655)">
    <circle cx="0" cy="0" r="170" fill="#FFF0CA" stroke="none" stroke-width="3" />
    <line id="gainigf1-pointer" x1="0" y1="0" x2="0" y2="-150" stroke="#000" stroke-width="15" stroke-linecap="round" />
</g>

<g id="knob-levelacth" transform="translate(1540, 1220)">
    <circle cx="0" cy="0" r="100" fill="#000" stroke="#000" stroke-width="3" />
    <line id="levelacth-pointer" x1="0" y1="0" x2="0" y2="-100" stroke="#ffffff" stroke-width="15" stroke-linecap="round" />
</g>

<g id="knob-levelgh" transform="translate(950, 940)">
    <circle cx="0" cy="0" r="100" fill="#000" stroke="#000" stroke-width="3" />
    <line id="levelgh-pointer" x1="0" y1="0" x2="0" y2="-100" stroke="#ffffff" stroke-width="15" stroke-linecap="round" />
</g>

<g id="knob-leveligf1" transform="translate(345, 1220)">
    <circle cx="0" cy="0" r="100" fill="#000" stroke="#000" stroke-width="3" />
    <line id="leveligf1-pointer" x1="0" y1="0" x2="0" y2="-100" stroke="#ffffff" stroke-width="15" stroke-linecap="round" />
</g>
        </svg>
    </div>

    <!-- Graph -->
    <div id="graph"></div>

<script>
  // Resize Plotly on window changes
  window.addEventListener('resize', () => {
    Plotly.Plots.resize(document.getElementById('graph'));
  });

  // X‑axis (same as yours)
  const frequency = [
    20.0, 25.1785, 31.6979, 39.9052, 50.2377, 63.2456, 79.6214, 100.2374, 126.1915, 158.8656,
    200.0, 251.7851, 316.9786, 399.0525, 502.3773, 632.4555, 796.2143, 1002.3745, 1261.9147, 1588.6565,
    2000.0, 2517.8508, 3169.7864, 3990.5246, 5023.7729, 6324.5553, 7962.1434, 10023.7447, 12619.1469, 15886.5647,
    20000.0
  ];

  // Data containers
  let gainData  = []; // entries like { positions:{ gainacth, gaingh, gainigf1 }, data:[...] }
  let levelData = []; // entries like { positions:{ levelacth, levelgh, leveligf1 }, data:[...] }

  // Knob state (0..10)
  const knobState = {
    gainacth: 5, gaingh: 5, gainigf1: 5,
    levelacth: 5, levelgh: 5, leveligf1: 5
  };

  // Angle (-135..135) -> index (0..10)
  function angleToIndex(angle) {
    const clamped = Math.max(-135, Math.min(135, angle));
    return Math.round(((clamped + 135) / 270) * 10);
  }

  // Load both datasets (works if your files are .json or .js with JSON content)
  function loadDatasetsAndPlot() {
    const gainURL  = 'https://thomasbe86.github.io/plotly-plot/TRI-HORMONIC-PHALANXGAIN.json';
    const levelURL = 'https://thomasbe86.github.io/plotly-plot/TRI-HORMONIC-PHALANXLEVEL.json';

    Promise.all([fetch(gainURL), fetch(levelURL)])
      .then(([r1, r2]) => {
        if (!r1.ok) throw new Error("GAIN HTTP " + r1.status);
        if (!r2.ok) throw new Error("LEVEL HTTP " + r2.status);
        return Promise.all([r1.json(), r2.json()]);
      })
      .then(([gData, lData]) => {
        gainData  = gData;
        levelData = lData;
        updatePlot();
      })
      .catch(err => console.error("Dataset load error:", err));
  }

  // Finders that only check the fields that exist in each file
  function findGainMatch(gainacth, gaingh, gainigf1) {
    return gainData.find(entry =>
      entry.positions &&
      entry.positions.gainacth === gainacth &&
      entry.positions.gaingh   === gaingh &&
      entry.positions.gainigf1 === gainigf1
    );
  }

  function findLevelMatch(levelacth, levelgh, leveligf1) {
    return levelData.find(entry =>
      entry.positions &&
      entry.positions.levelacth === levelacth &&
      entry.positions.levelgh   === levelgh &&
      entry.positions.leveligf1 === leveligf1
    );
  }

  function updatePlot() {
    const { gainacth, gaingh, gainigf1, levelacth, levelgh, leveligf1 } = knobState;

    const gainMatch  = findGainMatch(gainacth, gaingh, gainigf1);
    const levelMatch = findLevelMatch(levelacth, levelgh, leveligf1);

    if (!gainMatch && !levelMatch) {
      console.warn('No matches for current knobState:', knobState);
      return;
    }

    const traces = [];
    if (gainMatch) {
      traces.push({
        x: frequency,
        y: gainMatch.data,
        type: 'scatter', mode: 'lines',
        name: `Gains @ ACTH:${gainacth} GH:${gaingh} IGF1:${gainigf1}`,
        line: { color: 'red', width: 3, shape: 'spline' } // solid
      });
    }
    if (levelMatch) {
      traces.push({
        x: frequency,
        y: levelMatch.data,
        type: 'scatter', mode: 'lines',
        name: `Levels @ ACTH:${levelacth} GH:${levelgh} IGF1:${leveligf1}`,
        line: { color: 'blue', width: 3, dash: 'dash', shape: 'spline' } // dashed
      });
    }

    Plotly.newPlot('graph', traces, {
      title: {
        text:
          `<a href='https://rhpfelectronics.com/rhpf-electronics-handmade-guitar-pedals-in-switzerland/rhpf-nerd-lab/' target='_blank'>RhPf Electronics</a> – Tri‑Harmonic Phalanx - Tri-Band Enhancer`,
        font: { size: 10 }
      },
      xaxis: {
        title: { text: 'Frequency (Hz)', font: { size: 9 } },
        type: 'log',
        tickvals: [20,32,64,128,256,512,1000,2000,4000,8000,16000,20000],
        ticktext: ["20","32","64","128","256","512","1k","2k","4k","8k","16k","20k"]
      },
      yaxis: { title: { text: 'Gain (dB)', font: { size: 9 } }, range: [-15, 55] },
      legend: { font: { size: 9 } },
      margin: { t: 48, l: 50, r: 20, b: 50 }
    });
  }

  // ---- Knob UI ----
  function updatePointer(pointerId, angle) {
    document.getElementById(pointerId).setAttribute('transform', `rotate(${angle} 0 0)`);
  }

  const knobs = {
    gainacth:  { element: document.getElementById('knob-gainacth'),  pointerId: 'gainacth-pointer',  angle: 0 },
    gaingh:    { element: document.getElementById('knob-gaingh'),    pointerId: 'gaingh-pointer',    angle: 0 },
    gainigf1:  { element: document.getElementById('knob-gainigf1'),  pointerId: 'gainigf1-pointer',  angle: 0 },
    levelacth: { element: document.getElementById('knob-levelacth'), pointerId: 'levelacth-pointer', angle: 0 },
    levelgh:   { element: document.getElementById('knob-levelgh'),   pointerId: 'levelgh-pointer',   angle: 0 },
    leveligf1: { element: document.getElementById('knob-leveligf1'), pointerId: 'leveligf1-pointer', angle: 0 }
  };

  function updateKnob(knobKey, angle) {
    const knob = knobs[knobKey];
    knob.angle = angle;
    updatePointer(knob.pointerId, angle);
    knobState[knobKey] = angleToIndex(angle);
    updatePlot();
  }

  function addKnobListeners(knobKey) {
    const knob = knobs[knobKey];
    const { element } = knob;

    const startEvent = (event) => {
      event.preventDefault();
      const isTouch = event.type === "touchstart";
      const rect = element.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;

      const moveEvent = (e) => {
        const p = isTouch ? e.touches[0] : e;
        const dx = p.clientX - cx;
        const dy = p.clientY - cy;
        let angle = Math.atan2(dy, dx) * (180 / Math.PI);
        angle = Math.max(-135, Math.min(135, angle));
        updateKnob(knobKey, angle);
      };

      const endEvent = () => {
        document.removeEventListener(isTouch ? "touchmove" : "mousemove", moveEvent);
        document.removeEventListener(isTouch ? "touchend" : "mouseup", endEvent);
      };

      document.addEventListener(isTouch ? "touchmove" : "mousemove", moveEvent);
      document.addEventListener(isTouch ? "touchend" : "mouseup", endEvent);
    };

    element.addEventListener("mousedown", startEvent);
    element.addEventListener("touchstart", startEvent, { passive: false });

    element.addEventListener("wheel", (event) => {
      event.preventDefault();
      const delta = event.deltaY > 0 ? -15 : 15;
      let newAngle = knob.angle + delta;
      newAngle = Math.max(-135, Math.min(135, newAngle));
      updateKnob(knobKey, newAngle);
    });
  }

  // Init
  Object.keys(knobs).forEach(k => {
    updatePointer(knobs[k].pointerId, knobs[k].angle);
    addKnobListeners(k);
  });
  loadDatasetsAndPlot();
</script>
